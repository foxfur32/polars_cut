import polars as pl
from typing import Sequence, Optional, Union

def cut_polars(
    col: Union[str, pl.Expr],
    bins: Sequence[float],
    labels: Optional[Sequence[str]] = None,
    *,
    right: bool = True,
    include_lowest: bool = False,
    categorical: bool = True,
    label_precision: int = 3,
) -> pl.Expr:
    """
    Discretize a continuous column into bins (pd.cut-like), returning a Polars expression.
    """

    expr = pl.col(col) if isinstance(col, str) else col

    if len(bins) < 2:
        raise ValueError("`bins` must have at least two edges.")
    if any(bins[i] >= bins[i+1] for i in range(len(bins)-1)):
        raise ValueError("`bins` must be strictly increasing.")
    n_bins = len(bins) - 1

    if labels is not None and len(labels) != n_bins:
        raise ValueError("`labels` length must equal len(bins) - 1.")

    # Generate default interval labels if not provided
    def _fmt(x: float) -> str:
        return f"{x:.{label_precision}g}"

    if labels is None:
        labels = []
        for i in range(n_bins):
            lo, hi = bins[i], bins[i+1]
            if right:
                left_br = "[" if (i == 0 and include_lowest) else "("
                labels.append(f"{left_br}{_fmt(lo)}, {_fmt(hi)}]")
            else:
                labels.append(f"[{_fmt(lo)}, {_fmt(hi)})")

    # Build chained conditions returning labels directly
    when_expr = None
    for i in range(n_bins):
        lo, hi = bins[i], bins[i+1]
        if right:
            cond = (expr > lo) & (expr <= hi)
            if i == 0 and include_lowest:
                cond = (expr >= lo) & (expr <= hi)
        else:
            cond = (expr >= lo) & (expr < hi)

        this_expr = pl.when(cond).then(pl.lit(labels[i]))
        when_expr = this_expr if when_expr is None else when_expr.when(cond).then(pl.lit(labels[i]))

    out = when_expr.otherwise(None)

    return out.cast(pl.Categorical) if categorical else out.cast(pl.Utf8)

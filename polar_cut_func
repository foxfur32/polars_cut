import polars as pl
from typing import Sequence, Optional, Union

def cut_polars(
    col: Union[str, pl.Expr],
    bins: Sequence[float],
    labels: Optional[Sequence[str]] = None,
    *,
    right: bool = True,
    include_lowest: bool = False,
    categorical: bool = True,
    label_precision: int = 3,
    keep_nan: bool = True,                   # NEW default True
    nan_label: str = "NaN/Missing",          # default label for NaN/None
) -> pl.Expr:
    """
    Discretize a continuous column into bins (pd.cut-like), returning a Polars expression.

    Parameters
    ----------
    col : str | pl.Expr
        Column name or Polars expression.
    bins : sequence of float
        Bin edges, strictly increasing.
    labels : sequence of str | None
        Labels for bins. If None, interval strings are generated.
    right : bool, default True
        Right-closed bins if True, left-closed if False.
    include_lowest : bool, default False
        Include the lowest value in the first bin when right=True.
    categorical : bool, default True
        Cast output to categorical dtype.
    label_precision : int, default 3
        Precision for auto interval labels.
    keep_nan : bool, default True
        If True, always keep NaN/None as a separate category.
    nan_label : str, default "NaN/Missing"
        Label to assign for missing values.
    """
    expr = pl.col(col) if isinstance(col, str) else col

    if len(bins) < 2:
        raise ValueError("`bins` must have at least two edges.")
    if any(bins[i] >= bins[i+1] for i in range(len(bins)-1)):
        raise ValueError("`bins` must be strictly increasing.")
    n_bins = len(bins) - 1

    if labels is not None and len(labels) != n_bins:
        raise ValueError("`labels` length must equal len(bins) - 1.")

    def _fmt(x: float) -> str:
        return f"{x:.{label_precision}g}"

    if labels is None:
        labels = []
        for i in range(n_bins):
            lo, hi = bins[i], bins[i+1]
            if right:
                left_br = "[" if (i == 0 and include_lowest) else "("
                labels.append(f"{left_br}{_fmt(lo)}, {_fmt(hi)}]")
            else:
                labels.append(f"[{_fmt(lo)}, {_fmt(hi)})")

    # Build conditions
    when_expr = None
    for i in range(n_bins):
        lo, hi = bins[i], bins[i+1]
        if right:
            cond = (expr > lo) & (expr <= hi)
            if i == 0 and include_lowest:
                cond = (expr >= lo) & (expr <= hi)
        else:
            cond = (expr >= lo) & (expr < hi)

        this_expr = pl.when(cond).then(pl.lit(labels[i]))
        when_expr = this_expr if when_expr is None else when_expr.when(cond).then(pl.lit(labels[i]))

    out = when_expr.otherwise(None)

    # Handle NaN/None explicitly
    if keep_nan:
        out = pl.when(expr.is_null() | expr.cast(pl.Float64).is_nan()).then(nan_label).otherwise(out)

    return out.cast(pl.Categorical) if categorical else out.cast(pl.Utf8)

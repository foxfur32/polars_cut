match = re.match(r'[\[\(]\s*([-\d\.]+)\s*,\s*([-\d\.]+)\s*[\]\)]', iv)

import polars as pl
from typing import Sequence, Optional, Union

def cut_polars(
    col: Union[str, pl.Expr],
    bins: Sequence[float],
    labels: Optional[Sequence[str]] = None,
    *,
    right: bool = True,
    include_lowest: bool = False,
    categorical: bool = True,
    label_precision: int = 3,
    keep_nan: bool = True,                   # default True
    nan_label: str = "NaN/Missing",          # label for NaN/None
) -> pl.Expr:
    """
    Discretize a continuous column into bins (pd.cut-like), returning a Polars expression.
    NaN/None values are preserved as their own category by default.
    """
    expr = pl.col(col) if isinstance(col, str) else col

    if len(bins) < 2:
        raise ValueError("`bins` must have at least two edges.")
    if any(bins[i] >= bins[i+1] for i in range(len(bins)-1)):
        raise ValueError("`bins` must be strictly increasing.")
    n_bins = len(bins) - 1

    if labels is not None and len(labels) != n_bins:
        raise ValueError("`labels` length must equal len(bins) - 1.")

    # Format helper
    def _fmt(x: float) -> str:
        return f"{x:.{label_precision}g}"

    # Default labels if none provided
    if labels is None:
        labels = []
        for i in range(n_bins):
            lo, hi = bins[i], bins[i+1]
            if right:
                left_br = "[" if (i == 0 and include_lowest) else "("
                labels.append(f"{left_br}{_fmt(lo)}, {_fmt(hi)}]")
            else:
                labels.append(f"[{_fmt(lo)}, {_fmt(hi)})")

    # Build chained conditions for binning
    when_expr = None
    for i in range(n_bins):
        lo, hi = bins[i], bins[i+1]
        if right:
            cond = (expr > lo) & (expr <= hi)
            if i == 0 and include_lowest:
                cond = (expr >= lo) & (expr <= hi)
        else:
            cond = (expr >= lo) & (expr < hi)

        this_expr = pl.when(cond).then(pl.lit(labels[i]))
        when_expr = this_expr if when_expr is None else when_expr.when(cond).then(pl.lit(labels[i]))

    out = when_expr.otherwise(None)

    # Handle NaN/None explicitly
    if keep_nan:
        out = (
            pl.when(expr.is_null() | expr.cast(pl.Float64).is_nan())
            .then(pl.lit(nan_label))     # âœ… use pl.lit() here
            .otherwise(out)
        )

    return out.cast(pl.Categorical) if categorical else out.cast(pl.Utf8)


def get_lower_bounds(intervals):
    # Regex: capture left and right numbers (int, float, scientific, +/-, inf)
    num_pattern = r'[-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?|[-+]?inf'
    pattern = re.compile(rf'[\[\(]\s*({num_pattern})\s*,\s*({num_pattern})\s*[\]\)]')

    lower_bounds = []
    for iv in intervals:
        match = pattern.match(iv.strip())
        if not match:
            raise ValueError(f"Invalid interval: {iv}")
        left = match.group(1)
        # handle inf properly
        if left.lower() in ("inf", "+inf"):
            lower = float("inf")
        elif left.lower() == "-inf":
            lower = float("-inf")
        else:
            lower = float(left)
        lower_bounds.append(lower)
    return lower_bounds


# Example
intervals = ["(2.5e3, 4.1E2]", "[1e-3, 5)", "(-inf, 1]", "(3.2, inf)"]
print(get_lower_bounds(intervals))
